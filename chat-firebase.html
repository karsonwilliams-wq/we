<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Realtime Firestore Chat ‚Äî Channels, Reactions, Edit/Delete</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap">
<style>
  :root{
    --bg:#0b0d0f;
    --panel:#0f1316;
    --muted:#97a0a8;
    --accent:#5865f2;
    --card:#111316;
    --text:#e6eef3;
    --muted-2:#8b98a3;
  }
  *{box-sizing:border-box;font-family:Inter,system-ui,-apple-system,"Segoe UI",Roboto,Arial}
  html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg),#050607);color:var(--text)}
  .app{display:grid;grid-template-columns:220px 1fr;gap:12px;height:100vh;padding:12px}
  .sidebar{background:var(--panel);border-radius:10px;padding:12px;display:flex;flex-direction:column;gap:12px}
  .sidebar h3{margin:0;color:var(--muted);font-weight:600;font-size:0.95rem}
  .channels{display:flex;flex-direction:column;gap:6px;overflow:auto;padding-right:6px}
  .channel-btn{display:flex;align-items:center;gap:8px;padding:8px;border-radius:8px;background:transparent;border:none;color:var(--muted);cursor:pointer;text-align:left}
  .channel-btn.active{background:linear-gradient(90deg,rgba(88,101,242,0.12),transparent);color:var(--text);border:1px solid rgba(88,101,242,0.12)}
  .channel-create{display:flex;gap:8px}
  .channel-input{flex:1;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:var(--text)}
  .btn{background:var(--accent);color:white;border:none;padding:8px 10px;border-radius:8px;cursor:pointer}
  .ghost{background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--muted)}
  .main{display:flex;flex-direction:column;gap:12px}
  .topbar{display:flex;align-items:center;justify-content:space-between;gap:12px}
  .search{padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:var(--text)}
  .username-input{padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:var(--text)}
  .chat-window{flex:1;display:flex;flex-direction:column;background:var(--card);border-radius:10px;overflow:hidden}
  .messages{padding:14px;overflow:auto;flex:1;display:flex;flex-direction:column;gap:10px}
  .message{padding:10px;border-radius:8px;background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);display:flex;flex-direction:column;gap:8px;position:relative}
  .meta{display:flex;gap:8px;align-items:center;color:var(--muted);font-size:.85rem}
  .meta .time{margin-left:auto;color:var(--muted-2);font-size:.8rem}
  .text{white-space:pre-wrap;color:var(--text);font-size:1rem}
  .edited{color:var(--muted-2);font-size:.8rem;margin-left:6px}
  .message-actions{position:absolute;top:8px;right:8px;display:flex;gap:6px}
  .icon-btn{background:transparent;border:none;color:var(--muted);cursor:pointer;padding:6px;border-radius:6px}
  .icon-btn:hover{color:var(--text);background:rgba(255,255,255,0.02)}
  .reactions{display:flex;gap:8px;flex-wrap:wrap;margin-top:6px}
  .reaction-chip{display:inline-flex;align-items:center;gap:6px;padding:6px 8px;border-radius:999px;background:rgba(255,255,255,0.02);color:var(--text);font-size:.95rem;cursor:pointer;border:1px solid rgba(255,255,255,0.02)}
  .reaction-chip.self{outline:2px solid rgba(88,101,242,0.18)}
  .reaction-chip .count{opacity:.9;color:var(--muted-2);font-size:.85rem;margin-left:4px}
  .composer{padding:12px;border-top:1px solid rgba(255,255,255,0.02);display:flex;gap:8px;align-items:center}
  .compose-input{flex:1;padding:12px;border-radius:10px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:var(--text);min-height:44px}
  .badge{background:rgba(255,255,255,0.03);color:var(--muted);padding:6px 8px;border-radius:999px;font-size:.85rem}
  .modal-backdrop{position:fixed;inset:0;background:rgba(0,0,0,0.6);display:flex;align-items:center;justify-content:center;z-index:999}
  .modal{background:var(--panel);padding:16px;border-radius:10px;width:420px;color:var(--text)}
  .muted{color:var(--muted)}
  @media (max-width:880px){
    .app{grid-template-columns:1fr; padding:8px}
    .sidebar{order:2;display:flex;flex-direction:row;gap:8px;overflow:auto}
    .channel-create{display:none}
  }
</style>
</head>
<body>
<div class="app" id="app">
  <aside class="sidebar">
    <div style="display:flex;align-items:center;justify-content:space-between">
      <h3>Channels</h3>
      <div class="small muted">Realtime ¬∑ Firestore</div>
    </div>

    <div id="channelList" class="channels" role="list"></div>

    <div class="channel-create">
      <input id="newChannelName" class="channel-input" placeholder="new channel name" />
      <button id="createChannel" class="btn">Create</button>
    </div>

    <div style="display:flex;gap:8px;justify-content:space-between;align-items:center">
      <div class="small muted" id="channelsCount"></div>
      <div style="display:flex;gap:6px">
        <button id="exportBtn" class="ghost btn" title="Export local copy">Export</button>
      </div>
    </div>
  </aside>

  <main class="main">
    <div class="topbar">
      <input id="search" class="search" placeholder="Search messages (local)" />
      <div class="controls">
        <input id="username" class="username-input" placeholder="Your name" />
        <div class="badge" id="stats">0 msgs ¬∑ 0 reacts</div>
      </div>
    </div>

    <section class="chat-window" aria-live="polite">
      <div id="messages" class="messages"></div>

      <div class="composer">
        <textarea id="composeInput" class="compose-input" placeholder="Message (Enter to send)"></textarea>
        <div class="compose-actions">
          <div id="emojiQuick" style="display:flex;gap:6px">
            <button class="emoji-btn">üëç</button>
            <button class="emoji-btn">‚ù§Ô∏è</button>
            <button class="emoji-btn">üòÇ</button>
            <button class="emoji-btn">üòÆ</button>
            <button class="emoji-btn">üëé</button>
          </div>
          <button id="sendBtn" class="btn">Send</button>
        </div>
      </div>
    </section>
  </main>
</div>

<!-- passcode modal (client-side) -->
<div id="passcodeModal" class="modal-backdrop" style="display:none">
  <div class="modal">
    <h3 id="modalTitle">Enter passcode</h3>
    <div id="setHint" class="muted" style="margin-bottom:8px">No passcode set ‚Äî create one now. Keep it safe.</div>
    <label>Passcode
      <input id="passcodeInput" style="width:100%;padding:8px;margin-top:6px;border-radius:6px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:var(--text)" />
    </label>
    <label id="confirmWrap" style="display:block;margin-top:8px">Confirm passcode
      <input id="passcodeConfirm" style="width:100%;padding:8px;margin-top:6px;border-radius:6px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:var(--text)" />
    </label>
    <div style="margin-top:10px;display:flex;gap:8px;justify-content:flex-end">
      <button id="passSubmit" class="btn">OK</button>
    </div>
    <div id="passError" class="muted" style="margin-top:8px;color:#e74c3c;display:none"></div>
  </div>
</div>

<script type="module">
/* Firebase Firestore realtime single-file chat
   - Replace firebaseConfig with your project's config (see README text below).
   - Anonymous Auth used to identify users.
   - Collections:
     - channels (id, name, createdAt)
     - messages (id, channelId, userId, username, text, timestamp, editedAt)
     - reactions (id, messageId, emoji, userId, username, timestamp)
   - Realtime subscriptions with onSnapshot provide live updates.
*/

// --------- Firebase config (REPLACE with your config) ----------
const firebaseConfig = {
  // copy the config from your Firebase project settings
  // example:
  // apiKey: "AIza....",
  // authDomain: "your-project.firebaseapp.com",
  // projectId: "your-project-id",
  // storageBucket: "your-project-id.appspot.com",
  // messagingSenderId: "1234567890",
  // appId: "1:123456789:web:abcdef"
};
// ----------------------------------------------------------------

import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-auth.js";
import {
  getFirestore, collection, addDoc, doc, onSnapshot, query, where, orderBy,
  serverTimestamp, updateDoc, deleteDoc, getDocs, writeBatch, setDoc
} from "https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore.js";

if (!firebaseConfig || !firebaseConfig.projectId) {
  alert('Please open the HTML and paste your Firebase config into the firebaseConfig object near the top of the file. See setup instructions in the message where you got this file.');
  throw new Error('Missing Firebase config');
}

const app = initializeApp(firebaseConfig);
const auth = getAuth(app);
const db = getFirestore(app);

const CHANNELS_COL = 'channels';
const MESSAGES_COL = 'messages';
const REACTIONS_COL = 'reactions';

let currentChannelId = null;
let unsubscribeMessages = null;
let user = null;

// DOM
const channelListEl = document.getElementById('channelList');
const channelsCountEl = document.getElementById('channelsCount');
const newChannelNameEl = document.getElementById('newChannelName');
const createChannelBtn = document.getElementById('createChannel');
const messagesEl = document.getElementById('messages');
const usernameEl = document.getElementById('username');
const composeInput = document.getElementById('composeInput');
const sendBtn = document.getElementById('sendBtn');
const statsEl = document.getElementById('stats');
const exportBtn = document.getElementById('exportBtn');
const searchEl = document.getElementById('search');

const PASS_HASH_KEY = 'chat_fire_pass_hash';
const UNLOCKED_KEY = 'chat_fire_unlocked';

// ---------- Initialization ----------
(async function init(){
  await ensurePasscodeUnlocked();
  await firebaseSignIn();
  initUI();
  subscribeChannels();
  // load or create default channel
  await ensureDefaultChannel();
  updateStatsPeriodically();
})();

// ---------- Passcode (client-side) ----------
async function hashText(text){
  const enc = new TextEncoder();
  const data = enc.encode(text);
  const digest = await crypto.subtle.digest('SHA-256', data);
  return Array.from(new Uint8Array(digest)).map(b=>b.toString(16).padStart(2,'0')).join('');
}

async function ensurePasscodeUnlocked(){
  const storedHash = localStorage.getItem(PASS_HASH_KEY);
  const unlocked = localStorage.getItem(UNLOCKED_KEY) === '1';
  const modal = document.getElementById('passcodeModal');
  const modalTitle = document.getElementById('modalTitle');
  const setHint = document.getElementById('setHint');
  const confirmWrap = document.getElementById('confirmWrap');
  const passError = document.getElementById('passError');
  const passInput = document.getElementById('passcodeInput');
  const passConfirm = document.getElementById('passcodeConfirm');
  const passSubmit = document.getElementById('passSubmit');

  if (unlocked && storedHash) {
    modal.style.display='none';
    return;
  }

  modal.style.display='flex';
  if (!storedHash) {
    modalTitle.textContent = 'Set a passcode';
    setHint.style.display='block';
    confirmWrap.style.display='block';
  } else {
    modalTitle.textContent = 'Enter passcode';
    setHint.style.display='none';
    confirmWrap.style.display='none';
  }
  passError.style.display='none';
  passInput.value = '';
  passConfirm.value = '';

  return new Promise(resolve => {
    passSubmit.onclick = async () => {
      passError.style.display = 'none';
      const p = passInput.value || '';
      if (!p) { passError.textContent = 'Passcode cannot be empty'; passError.style.display='block'; return; }
      if (!storedHash) {
        const c = passConfirm.value || '';
        if (p !== c) { passError.textContent = "Passcodes don't match"; passError.style.display='block'; return; }
        const h = await hashText(p);
        localStorage.setItem(PASS_HASH_KEY, h);
        localStorage.setItem(UNLOCKED_KEY, '1');
        modal.style.display='none';
        resolve();
        return;
      } else {
        const h = await hashText(p);
        if (h === storedHash) {
          localStorage.setItem(UNLOCKED_KEY, '1');
          modal.style.display='none';
          resolve();
          return;
        } else {
          passError.textContent = 'Incorrect passcode';
          passError.style.display='block';
          return;
        }
      }
    };
  });
}

// ---------- Firebase Auth (anonymous) ----------
async function firebaseSignIn(){
  signInAnonymously(auth).catch(err => {
    console.error('Auth error', err);
    alert('Failed to sign in anonymously: ' + err.message);
  });
  return new Promise(resolve => {
    onAuthStateChanged(auth, (u) => {
      if (u) {
        user = u;
        // restore username if saved
        usernameEl.value = localStorage.getItem('chat_username_firebase') || ('User' + Math.floor(Math.random()*10000));
        localStorage.setItem('chat_username_firebase', usernameEl.value);
        resolve();
      }
    });
  });
}

// ---------- Channels (realtime) ----------
function subscribeChannels(){
  const col = collection(db, CHANNELS_COL);
  const q = query(col, orderBy('name'));
  onSnapshot(q, snapshot => {
    const channels = [];
    snapshot.forEach(docSnap => {
      channels.push({ id: docSnap.id, ...docSnap.data() });
    });
    renderChannelList(channels);
  }, err => console.error('channels onSnapshot', err));
}

function renderChannelList(channels){
  channelListEl.innerHTML = '';
  channels.forEach(ch => {
    const btn = document.createElement('button');
    btn.className = 'channel-btn' + (ch.id === currentChannelId ? ' active':'');
    btn.innerHTML = `<span># ${escapeHtml(ch.name)}</span>`;
    btn.onclick = async () => {
      if (currentChannelId === ch.id) return;
      currentChannelId = ch.id;
      localStorage.setItem('chat_current_channel_firebase', ch.id);
      await subscribeMessagesForChannel(ch.id);
      renderChannelList(channels);
    };
    // small actions
    const actions = document.createElement('div');
    actions.style.marginLeft = 'auto';
    const renameBtn = document.createElement('button');
    renameBtn.className = 'icon-btn';
    renameBtn.textContent = '‚úèÔ∏è';
    renameBtn.title = 'Rename';
    renameBtn.onclick = async (ev) => {
      ev.stopPropagation();
      const newName = prompt('Rename channel', ch.name);
      if (newName && newName.trim()) {
        const chDoc = doc(db, CHANNELS_COL, ch.id);
        await updateDoc(chDoc, { name: newName.trim() });
      }
    };
    const delBtn = document.createElement('button');
    delBtn.className = 'icon-btn';
    delBtn.textContent = 'üóëÔ∏è';
    delBtn.title = 'Delete channel';
    delBtn.onclick = async (ev) => {
      ev.stopPropagation();
      if (!confirm('Delete channel and its messages?')) return;
      // delete messages and reactions in batches
      const msgsQ = query(collection(db, MESSAGES_COL), where('channelId', '==', ch.id));
      const msgsSnap = await getDocs(msgsQ);
      const batch = writeBatch(db);
      msgsSnap.forEach(mdoc => {
        batch.delete(doc(db, MESSAGES_COL, mdoc.id));
      });
      await batch.commit();
      await deleteDoc(doc(db, CHANNELS_COL, ch.id));
      if (currentChannelId === ch.id) {
        currentChannelId = null;
        await ensureDefaultChannel();
      }
    };
    actions.appendChild(renameBtn);
    actions.appendChild(delBtn);
    btn.appendChild(actions);
    channelListEl.appendChild(btn);
  });
  channelsCountEl.textContent = `${channels.length} channel${channels.length===1?'':'s'}`;
}

// create channel
createChannelBtn.onclick = async () => {
  const name = newChannelNameEl.value.trim();
  if (!name) { alert('Channel name required'); return; }
  const colRef = collection(db, CHANNELS_COL);
  const docRef = await addDoc(colRef, { name, createdAt: Date.now() });
  newChannelNameEl.value = '';
  currentChannelId = docRef.id;
  localStorage.setItem('chat_current_channel_firebase', docRef.id);
  await subscribeMessagesForChannel(docRef.id);
};

// ensure default channel exists
async function ensureDefaultChannel(){
  const colRef = collection(db, CHANNELS_COL);
  // get first channel
  const snapshot = await getDocs(query(colRef, orderBy('name')));
  if (!snapshot.empty) {
    const first = snapshot.docs[0];
    const saved = localStorage.getItem('chat_current_channel_firebase');
    currentChannelId = saved || first.id;
    await subscribeMessagesForChannel(currentChannelId);
    return;
  }
  // create default channel
  const r = await addDoc(colRef, { name: 'general', createdAt: Date.now() });
  currentChannelId = r.id;
  localStorage.setItem('chat_current_channel_firebase', r.id);
  await subscribeMessagesForChannel(r.id);
}

// ---------- Messages subscription (realtime) ----------
async function subscribeMessagesForChannel(channelId){
  if (unsubscribeMessages) unsubscribeMessages();
  messagesEl.innerHTML = '<div class="muted">Loading messages‚Ä¶</div>';
  currentChannelId = channelId;
  const msgsRef = collection(db, MESSAGES_COL);
  const q = query(msgsRef, where('channelId', '==', channelId), orderBy('timestamp'));
  const snapUnsub = onSnapshot(q, async snap => {
    // we'll build a map of messages and then fetch reactions for visible messages
    const messages = [];
    snap.forEach(d => messages.push({ id: d.id, ...d.data() }));
    await renderMessagesRealtime(messages);
  }, err => console.error('messages onSnapshot', err));
  unsubscribeMessages = snapUnsub;
}

// render messages and attach reaction subscriptions per message (we fetch reactions once per render)
async function renderMessagesRealtime(messages){
  // fetch reactions for message ids
  const messageIds = messages.map(m => m.id);
  let reactions = [];
  if (messageIds.length > 0) {
    const reactsRef = collection(db, REACTIONS_COL);
    // fetch all reactions for these messages (one getDocs)
    // Note: firestore doesn't support where-in with many items extremely large; for moderate counts it's fine.
    const CHUNK_SIZE = 10;
    for (let i = 0; i < messageIds.length; i += CHUNK_SIZE) {
      const chunk = messageIds.slice(i, i + CHUNK_SIZE);
      const q = query(reactsRef, where('messageId', 'in', chunk));
      const snap = await getDocs(q);
      snap.forEach(r => reactions.push({ id: r.id, ...r.data() }));
    }
  }
  // attach reactions to messages
  const byMsg = {};
  reactions.forEach(r => {
    byMsg[r.messageId] = byMsg[r.messageId] || [];
    byMsg[r.messageId].push(r);
  });

  // Render
  messagesEl.innerHTML = '';
  for (const m of messages) {
    const container = document.createElement('div');
    container.className = 'message';
    container.dataset.id = m.id;

    const meta = document.createElement('div');
    meta.className = 'meta';
    meta.innerHTML = `<strong style="color:var(--text)">${escapeHtml(m.username||m.user)}</strong>`;
    const timeSpan = document.createElement('span');
    timeSpan.className = 'time';
    timeSpan.textContent = new Date(m.timestamp).toLocaleString();
    meta.appendChild(timeSpan);
    if (m.editedAt) {
      const ed = document.createElement('span');
      ed.className = 'edited';
      ed.textContent = 'edited';
      meta.appendChild(ed);
    }

    // actions (only if author)
    const actions = document.createElement('div');
    actions.className = 'message-actions';
    if (user && m.userId === user.uid) {
      const editBtn = document.createElement('button'); editBtn.className='icon-btn'; editBtn.textContent='‚úèÔ∏è'; editBtn.title='Edit';
      editBtn.onclick = () => openEditUI(m);
      const delBtn = document.createElement('button'); delBtn.className='icon-btn'; delBtn.textContent='üóëÔ∏è'; delBtn.title='Delete';
      delBtn.onclick = async () => {
        if (!confirm('Delete this message?')) return;
        // delete reactions then message
        await deleteReactionsForMessage(m.id);
        await deleteDoc(doc(db, MESSAGES_COL, m.id));
      };
      actions.appendChild(editBtn); actions.appendChild(delBtn);
    }
    container.appendChild(actions);

    const textDiv = document.createElement('div');
    textDiv.className = 'text';
    textDiv.textContent = m.text || '';
    container.appendChild(meta);
    container.appendChild(textDiv);

    // reactions summary
    const reactsForMsg = byMsg[m.id] || [];
    const summary = makeReactionSummaryList(reactsForMsg);
    const reactionsDiv = document.createElement('div');
    reactionsDiv.className = 'reactions';
    for (const s of summary) {
      const chip = document.createElement('button');
      chip.className = 'reaction-chip' + (s.users.includes((user && user.uid) ? user.uid : '') ? ' self' : '');
      chip.innerHTML = `<span class="emoji">${escapeHtml(s.emoji)}</span><span class="count">${s.count}</span>`;
      chip.title = s.users.map(u => u.username || 'User').join(', ');
      chip.onclick = async () => {
        await toggleReaction(m.id, s.emoji);
      };
      reactionsDiv.appendChild(chip);
    }
    // reaction picker trigger
    const pickerBtn = document.createElement('button'); pickerBtn.className='reaction-chip'; pickerBtn.textContent='+';
    pickerBtn.title = 'Add reaction';
    pickerBtn.onclick = (ev) => {
      ev.stopPropagation();
      showEmojiPickerAt(ev.currentTarget, m.id);
    };
    reactionsDiv.appendChild(pickerBtn);

    container.appendChild(reactionsDiv);
    messagesEl.appendChild(container);
  }
  messagesEl.scrollTop = messagesEl.scrollHeight;
}

// ---------- Reactions ----------

function makeReactionSummaryList(reactions){
  // reactions: array of {emoji, userId, username}
  const map = new Map();
  for (const r of reactions){
    const key = r.emoji;
    if (!map.has(key)) map.set(key, { emoji: key, count: 0, users: [] });
    const o = map.get(key);
    o.count += 1;
    o.users.push({ userId: r.userId, username: r.username });
  }
  // convert users field to usernames for title
  return Array.from(map.values()).map(v => ({ emoji: v.emoji, count: v.count, users: v.users.map(u=> ({ userId: u.userId, username: u.username })) }));
}

async function toggleReaction(messageId, emoji){
  if (!user) return alert('Not signed in');
  // check for existing reaction by this user
  const reactsRef = collection(db, REACTIONS_COL);
  // fetch reactions matching messageId & emoji & userId
  const q = query(reactsRef, where('messageId', '==', messageId), where('emoji','==',emoji), where('userId','==',user.uid));
  const snap = await getDocs(q);
  if (!snap.empty) {
    // delete first matching (should be only one)
    const rdoc = snap.docs[0];
    await deleteDoc(doc(db, REACTIONS_COL, rdoc.id));
  } else {
    await addDoc(reactsRef, { messageId, emoji, userId: user.uid, username: getUsername(), timestamp: Date.now() });
  }
}

// delete reactions by messageId
async function deleteReactionsForMessage(messageId){
  const q = query(collection(db, REACTIONS_COL), where('messageId','==',messageId));
  const snap = await getDocs(q);
  const batch = writeBatch(db);
  snap.forEach(d => batch.delete(doc(db, REACTIONS_COL, d.id)));
  await batch.commit();
}

// ---------- Messages create / edit ----------
async function addMessageToCurrentChannel(text){
  if (!currentChannelId) return alert('No channel selected');
  if (!user) return alert('Auth required');
  const colRef = collection(db, MESSAGES_COL);
  await addDoc(colRef, {
    channelId: currentChannelId,
    userId: user.uid,
    username: getUsername(),
    text,
    timestamp: Date.now(),
    editedAt: null
  });
}

async function editMessage(msgId, newText){
  const mRef = doc(db, MESSAGES_COL, msgId);
  await updateDoc(mRef, { text: newText, editedAt: Date.now() });
}

// ---------- Edit UI ----------
function openEditUI(message){
  const node = messagesEl.querySelector(`[data-id="${message.id}"]`);
  if (!node) return;
  const textDiv = node.querySelector('.text');
  const old = message.text || '';
  const ta = document.createElement('textarea');
  ta.style.width = '100%';
  ta.style.minHeight = '64px';
  ta.value = old;
  const saveBtn = document.createElement('button'); saveBtn.className='btn'; saveBtn.textContent='Save';
  const cancelBtn = document.createElement('button'); cancelBtn.className='ghost btn'; cancelBtn.textContent='Cancel';
  const controls = document.createElement('div'); controls.style.display='flex'; controls.style.gap='8px'; controls.style.marginTop='8px';
  controls.appendChild(saveBtn); controls.appendChild(cancelBtn);
  textDiv.innerHTML = '';
  textDiv.appendChild(ta); textDiv.appendChild(controls);
  saveBtn.onclick = async () => {
    const newText = ta.value.trim();
    if (!newText) { alert('Message cannot be empty'); return; }
    await editMessage(message.id, newText);
  };
  cancelBtn.onclick = () => {
    // re-subscribe to refresh ui (or do nothing)
  };
}

// ---------- Emoji picker ----------
const EMOJI_SET = ['üëç','‚ù§Ô∏è','üòÇ','üòÆ','üò¢','üëè','üî•','üéâ','üòÖ','ü§î','ü§ù','üëÄ','‚ú®','‚ùó','‚ùå'];
let emojiPickerEl = null;

function showEmojiPickerAt(targetEl, messageId){
  hideEmojiPicker();
  emojiPickerEl = document.createElement('div');
  emojiPickerEl.style.position='absolute';
  emojiPickerEl.style.zIndex='9999';
  emojiPickerEl.style.background='var(--panel)';
  emojiPickerEl.style.padding='8px';
  emojiPickerEl.style.borderRadius='8px';
  emojiPickerEl.style.display='flex';
  emojiPickerEl.style.gap='6px';
  emojiPickerEl.style.boxShadow='0 6px 20px rgba(0,0,0,0.6)';
  for (const e of EMOJI_SET){
    const b = document.createElement('button');
    b.className = 'emoji-btn';
    b.textContent = e;
    b.onclick = async (ev) => {
      ev.stopPropagation();
      await toggleReaction(messageId, e);
      hideEmojiPicker();
    };
    emojiPickerEl.appendChild(b);
  }
  document.body.appendChild(emojiPickerEl);
  const rect = targetEl.getBoundingClientRect();
  emojiPickerEl.style.left = `${rect.left}px`;
  emojiPickerEl.style.top = `${rect.bottom + 6}px`;
  setTimeout(()=> document.addEventListener('click', hideEmojiPickerOnce), 0);
}

function hideEmojiPicker(){
  if (emojiPickerEl) { emojiPickerEl.remove(); emojiPickerEl = null; document.removeEventListener('click', hideEmojiPickerOnce); }
}
function hideEmojiPickerOnce(ev){ if (!emojiPickerEl) return; if (!emojiPickerEl.contains(ev.target)) hideEmojiPicker(); }

// ---------- UI wiring ----------
function getUsername(){
  const v = (usernameEl.value || '').trim();
  if (v) return v;
  const s = localStorage.getItem('chat_username_firebase') || '';
  if (s) return s;
  const auto = 'User' + Math.floor(Math.random()*10000);
  usernameEl.value = auto;
  localStorage.setItem('chat_username_firebase', auto);
  return auto;
}
usernameEl.addEventListener('change', () => localStorage.setItem('chat_username_firebase', usernameEl.value || ''));

sendBtn.addEventListener('click', async () => {
  const text = composeInput.value.trim();
  if (!text) return;
  await addMessageToCurrentChannel(text);
  composeInput.value = '';
});

composeInput.addEventListener('keydown', (e) => {
  if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); sendBtn.click(); }
});

document.querySelectorAll('#emojiQuick .emoji-btn').forEach(b => {
  b.addEventListener('click', () => {
    composeInput.value += b.textContent;
    composeInput.focus();
  });
});

// export current channel messages (local copy)
exportBtn.addEventListener('click', async ()=>{
  if (!currentChannelId) return alert('No channel');
  const msgsQ = query(collection(db, MESSAGES_COL), where('channelId','==',currentChannelId), orderBy('timestamp'));
  const snaps = await getDocs(msgsQ);
  const arr = snaps.docs.map(d => ({ id: d.id, ...d.data() }));
  const blob = new Blob([JSON.stringify({ channelId: currentChannelId, messages: arr }, null, 2)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = `channel-${currentChannelId}-export.json`; a.click();
  URL.revokeObjectURL(url);
});

// search
searchEl.addEventListener('input', () => {
  // this app uses server-side queries for messages but we fetch all visible messages via onSnapshot.
  // The search will re-filter displayed messages locally: re-run last snapshot handler by toggling current channel.
  if (currentChannelId) subscribeMessagesForChannel(currentChannelId);
});

// ---------- Helpers ----------
function escapeHtml(s=''){ return (s+'').replace(/[&<>"']/g, c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }

async function updateStatsPeriodically(){
  setInterval(async () => {
    const msgsSnap = await getDocs(collection(db, MESSAGES_COL));
    const reactsSnap = await getDocs(collection(db, REACTIONS_COL));
    statsEl.textContent = `${msgsSnap.size} msgs ¬∑ ${reactsSnap.size} reacts`;
  }, 4000);
}

</script>
</body>
</html>